#!/bin/bash

MOD_PATH='node_modules'
BIN_PATH="$MOD_PATH/.bin"
ROOT="${WAVE_ROOT:-`readlink -f "../"`}"
CONFIG_FILE='package.json'

while getopts "n:"  opt; do
	case $opt in
		n)
			MOD_PATH="$MOD_PATH/$OPTARG"
			;;
		\?)
			echo "Usage: node-link -n @namespace modules..."
			exit 1
			;;
	esac
done

shift $((OPTIND - 1))

# Parse modules and extract worktree information
# Using parallel arrays for compatibility with older bash versions
MODULE_WORKTREE_KEYS=()
MODULE_WORKTREE_VALUES=()
PARSED_MODULES=()

for MODULE_SPEC in "$@"; do
	if [[ "$MODULE_SPEC" == *"/"* ]]; then
		MODULE_NAME="${MODULE_SPEC%%/*}"
		WORKTREE="${MODULE_SPEC#*/}"
		MODULE_WORKTREE_KEYS+=("$MODULE_NAME")
		MODULE_WORKTREE_VALUES+=("$WORKTREE")
		PARSED_MODULES+=("$MODULE_NAME")
	else
		PARSED_MODULES+=("$MODULE_SPEC")
	fi
done

MODULES=("${PARSED_MODULES[@]}")

# Helper function to get worktree for a module
get_worktree() {
	local MODULE="$1"
	for i in "${!MODULE_WORKTREE_KEYS[@]}"; do
		if [[ "${MODULE_WORKTREE_KEYS[$i]}" == "$MODULE" ]]; then
			echo "${MODULE_WORKTREE_VALUES[$i]}"
			return
		fi
	done
}

# if no modules then print all symlinks found in $MOD_PATH

if [ -z "$MODULES" ]; then
	find "$MOD_PATH" -type l -depth 1 -print | xargs -I {} basename "{}"
	exit
fi

DEPS=$(find "$MOD_PATH" -type l -maxdepth 1)
DEPS+=$(echo "$PWD")

function gatherDeps() {
	local MODULE_DIR="$1"
	local WORKTREE=$(get_worktree "$MODULE_DIR")

	if [[ -n "$WORKTREE" ]]; then
		local WORK_PATH="$ROOT/$MODULE_DIR/.worktrees/$WORKTREE"
		if [[ -d "$WORK_PATH" ]]; then
			pushd "$WORK_PATH" > /dev/null
		else
			pushd "$ROOT/$MODULE_DIR" > /dev/null
		fi
	else
		if [[ -d "$ROOT/$MODULE_DIR" ]]; then
			pushd "$ROOT/$MODULE_DIR" > /dev/null
		else
			return
		fi
	fi

	MODULES+=("$MODULE_DIR")

	if [[ -d "$MOD_PATH" ]]; then
		SUB_DEPS=$(find "$MOD_PATH" -type l -maxdepth 1 2>/dev/null | xargs basename 2>/dev/null)
		for SUB_DEP in $SUB_DEPS; do
			MODULES+=("$SUB_DEP")
		done
	fi

	popd > /dev/null
}

function loopDeps() {
	local DIRS=("$1")
	for DIR in "${DIRS[@]}"; do
		if [[ -z $DIR ]]; then
			continue
		fi

		DEP=$(basename "$DIR")

		gatherDeps "$DEP"
	done
}

loopDeps "$MODULES"
loopDeps "$DEPS"

MODULES=($(echo "${MODULES[@]}" | tr ' ' '\n' | sort -u))

echo "found ${MODULES[@]}"

for DIR in "${MODULES[@]}"; do
	if [[ -z $DIR ]]; then
		continue
	fi

	pushd "$ROOT/$DIR" > /dev/null
	echo "checking $PWD"

	for MODULE in "${MODULES[@]}"; do
		MODULE_PATH="$MOD_PATH/$MODULE"

		if [[ -d "$MODULE_PATH" ]]; then
			rm -rf "$MODULE_PATH"

			# Check if this module has a worktree specified
			WORKTREE=$(get_worktree "$MODULE")
			if [[ -n "$WORKTREE" ]]; then
				WORKTREE_PATH="$ROOT/$MODULE/.worktrees/$WORKTREE"
				if [[ -d "$WORKTREE_PATH" ]]; then
					ln -s "$WORKTREE_PATH" "$MODULE_PATH"
					echo "linking $MODULE from $WORKTREE_PATH (worktree: $WORKTREE)"
					MODULE_SOURCE="$WORKTREE_PATH"
				else
					echo "Warning: worktree path $WORKTREE_PATH does not exist, falling back to main"
					ln -s "$ROOT/$MODULE" "$MODULE_PATH"
					echo "linking $MODULE from $ROOT"
					MODULE_SOURCE="$ROOT/$MODULE"
				fi
			else
				ln -s "$ROOT/$MODULE" "$MODULE_PATH"
				echo "linking $MODULE from $ROOT"
				MODULE_SOURCE="$ROOT/$MODULE"
			fi

			SCRIPTS=$(jq -r '.bin | to_entries | .[] | "\(.key):\(.value)"' $MODULE_SOURCE/$CONFIG_FILE 2> /dev/null)
			if [[ -n $SCRIPTS ]]; then
				for SCRIPT in $SCRIPTS; do
					CMD=$(echo $SCRIPT | cut -d ':' -f 1)
					CMD_PATH=$(echo $SCRIPT | cut -d ':' -f 2)

					echo "Attaching script $CMD to $CMD_PATH"

					rm -f "$BIN_PATH/$CMD"
					ln -s "$MODULE_SOURCE/$CMD_PATH" "$BIN_PATH/$CMD"
					chmod +x "$BIN_PATH/$CMD"
				done
			fi
		fi
	done


	popd > /dev/null
done






