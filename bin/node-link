#!/bin/bash

MOD_PATH='node_modules'
BIN_PATH="$MOD_PATH/.bin"
ROOT="${WAVE_ROOT:-`readlink -f "../"`}"
CONFIG_FILE='package.json'

UNLINK=false

while [[ $# -gt 0 ]]; do
	case $1 in
		--unlink)
			UNLINK=true
			shift
			;;
		-n)
			MOD_PATH="$MOD_PATH/$2"
			shift 2
			;;
		--)
			shift
			break
			;;
		-*)
			echo "Usage: node-link [-n @namespace] [--unlink] modules..."
			exit 1
			;;
		*)
			break
			;;
	esac
done

# Parse modules and extract worktree information
# Using parallel arrays for compatibility with older bash versions
MODULE_WORKTREE_KEYS=()
MODULE_WORKTREE_VALUES=()
PARSED_MODULES=()

for MODULE_SPEC in "$@"; do
	if [[ "$MODULE_SPEC" == *"/"* ]]; then
		MODULE_NAME="${MODULE_SPEC%%/*}"
		WORKTREE="${MODULE_SPEC#*/}"
		MODULE_WORKTREE_KEYS+=("$MODULE_NAME")
		MODULE_WORKTREE_VALUES+=("$WORKTREE")
		PARSED_MODULES+=("$MODULE_NAME")
	else
		PARSED_MODULES+=("$MODULE_SPEC")
	fi
done

MODULES=("${PARSED_MODULES[@]}")

# Helper function to get worktree name for a module
get_worktree() {
	local MODULE="$1"
	for i in "${!MODULE_WORKTREE_KEYS[@]}"; do
		if [[ "${MODULE_WORKTREE_KEYS[$i]}" == "$MODULE" ]]; then
			echo "${MODULE_WORKTREE_VALUES[$i]}"
			return
		fi
	done
}

# Resolve the actual path of a worktree by looking it up via git
resolve_worktree_path() {
	local MODULE="$1"
	local WORKTREE="$2"
	local MODULE_DIR="$ROOT/$MODULE"

	if [[ ! -d "$MODULE_DIR" ]]; then
		return 1
	fi

	local WORKTREE_PATH
	WORKTREE_PATH=$(git -C "$MODULE_DIR" worktree list --porcelain 2>/dev/null | awk -v name="$WORKTREE" '
		/^worktree / { path = substr($0, 10) }
		/^branch / {
			branch = substr($0, 8)
			# strip refs/heads/ prefix
			sub(/^refs\/heads\//, "", branch)
			if (branch == name) { print path; exit }
		}
	')

	if [[ -n "$WORKTREE_PATH" ]]; then
		echo "$WORKTREE_PATH"
		return 0
	fi

	return 1
}

# if no modules then print all symlinks found in $MOD_PATH

if [ -z "$MODULES" ]; then
	find "$MOD_PATH" -type l -depth 1 -print | xargs -I {} basename "{}"
	exit
fi

DEPS=$(find "$MOD_PATH" -type l -maxdepth 1)
DEPS+=$(echo "$PWD")

function gatherDeps() {
	local MODULE_DIR="$1"
	local WORKTREE=$(get_worktree "$MODULE_DIR")

	if [[ -n "$WORKTREE" ]]; then
		local WORK_PATH
		WORK_PATH=$(resolve_worktree_path "$MODULE_DIR" "$WORKTREE")
		if [[ $? -eq 0 && -d "$WORK_PATH" ]]; then
			pushd "$WORK_PATH" > /dev/null
		else
			pushd "$ROOT/$MODULE_DIR" > /dev/null
		fi
	else
		if [[ -d "$ROOT/$MODULE_DIR" ]]; then
			pushd "$ROOT/$MODULE_DIR" > /dev/null
		else
			return
		fi
	fi

	MODULES+=("$MODULE_DIR")

	if [[ -d "$MOD_PATH" ]]; then
		SUB_DEPS=$(find "$MOD_PATH" -type l -maxdepth 1 2>/dev/null | xargs basename 2>/dev/null)
		for SUB_DEP in $SUB_DEPS; do
			MODULES+=("$SUB_DEP")
		done
	fi

	popd > /dev/null
}

function loopDeps() {
	local DIRS=("$1")
	for DIR in "${DIRS[@]}"; do
		if [[ -z $DIR ]]; then
			continue
		fi

		DEP=$(basename "$DIR")

		gatherDeps "$DEP"
	done
}

loopDeps "$MODULES"
loopDeps "$DEPS"

MODULES=($(echo "${MODULES[@]}" | tr ' ' '\n' | sort -u))

echo "found ${MODULES[@]}"

MISSING_BACKUPS=()

for DIR in "${MODULES[@]}"; do
	if [[ -z $DIR ]]; then
		continue
	fi

	pushd "$ROOT/$DIR" > /dev/null
	echo "checking $PWD"

	for MODULE in "${MODULES[@]}"; do
		MODULE_PATH="$MOD_PATH/$MODULE"
		BACKUP_PATH="$MOD_PATH/_$MODULE"

		if $UNLINK; then
			# Unlink mode: remove symlink and restore backed-up module
			if [[ -L "$MODULE_PATH" ]]; then
				rm "$MODULE_PATH"
				if [[ -d "$BACKUP_PATH" ]]; then
					mv "$BACKUP_PATH" "$MODULE_PATH"
					echo "unlinked $MODULE, restored from backup"
				else
					MISSING_BACKUPS+=("$MODULE in $DIR")
					echo "unlinked $MODULE (no backup to restore)"
				fi
			fi
		else
			# Link mode: back up existing module and create symlink
			if [[ -d "$MODULE_PATH" ]]; then
				if [[ -L "$MODULE_PATH" ]]; then
					rm "$MODULE_PATH"
				else
					if [[ -d "$BACKUP_PATH" ]]; then
						rm -rf "$BACKUP_PATH"
					fi
					mv "$MODULE_PATH" "$BACKUP_PATH"
				fi

				# Check if this module has a worktree specified
				WORKTREE=$(get_worktree "$MODULE")
				if [[ -n "$WORKTREE" ]]; then
					WORKTREE_PATH=$(resolve_worktree_path "$MODULE" "$WORKTREE")
					if [[ $? -eq 0 && -d "$WORKTREE_PATH" ]]; then
						ln -s "$WORKTREE_PATH" "$MODULE_PATH"
						echo "linking $MODULE from $WORKTREE_PATH (worktree: $WORKTREE)"
						MODULE_SOURCE="$WORKTREE_PATH"
					else
						echo "Warning: worktree '$WORKTREE' not found for $MODULE, falling back to main"
						ln -s "$ROOT/$MODULE" "$MODULE_PATH"
						echo "linking $MODULE from $ROOT"
						MODULE_SOURCE="$ROOT/$MODULE"
					fi
				else
					ln -s "$ROOT/$MODULE" "$MODULE_PATH"
					echo "linking $MODULE from $ROOT"
					MODULE_SOURCE="$ROOT/$MODULE"
				fi

				SCRIPTS=$(jq -r '.bin | to_entries | .[] | "\(.key):\(.value)"' $MODULE_SOURCE/$CONFIG_FILE 2> /dev/null)
				if [[ -n $SCRIPTS ]]; then
					for SCRIPT in $SCRIPTS; do
						CMD=$(echo $SCRIPT | cut -d ':' -f 1)
						CMD_PATH=$(echo $SCRIPT | cut -d ':' -f 2)

						echo "Attaching script $CMD to $CMD_PATH"

						rm -f "$BIN_PATH/$CMD"
						ln -s "$MODULE_SOURCE/$CMD_PATH" "$BIN_PATH/$CMD"
						chmod +x "$BIN_PATH/$CMD"
					done
				fi
			fi
		fi
	done

	popd > /dev/null
done

if [[ ${#MISSING_BACKUPS[@]} -gt 0 ]]; then
	echo ""
	echo "Warning: The following modules could not be reinstated (no backup found):"
	for ENTRY in "${MISSING_BACKUPS[@]}"; do
		echo "  - $ENTRY"
	done
fi






